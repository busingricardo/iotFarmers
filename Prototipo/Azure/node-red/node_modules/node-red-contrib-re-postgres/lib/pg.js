var pg = require('pg');
var named = require('node-postgres-named');
var Cursor = require('pg-cursor');

module.exports=function(RED){

	function PostgresDatabaseNode(n) {
		RED.nodes.createNode(this, n);
		this.hostname = n.hostname;
		this.port = n.port;
		this.db = n.db;
		this.ssl = n.ssl;

		var credentials = this.credentials;
		if (credentials) {
			this.user = credentials.user;
			this.password = credentials.password;
		}
	}
	
	RED.nodes.registerType("postgresdb", PostgresDatabaseNode, {
		credentials: {
			user: {type: "text"},
			password: {type: "password"}
		}
	});


	function PostgresNode(n) {
		RED.nodes.createNode(this, n);
	
		var node = this;
	
		node.topic = n.topic;
		node.postgresdb = n.postgresdb;
		node.postgresConfig = RED.nodes.getNode(this.postgresdb);
		node.sqlquery = n.sqlquery;
		node.output = n.output;
		node.perrow = n.perrow;
		node.rowspermsg = n.rowspermsg;
		node.return_on_error = n.return_on_error;
		node.limit_queries = n.limit_queries;
		node.limit_by = n.limit_by;
		node.limit_value = n.limit_value;
		node.limit_drop_intermediate = n.limit_drop_intermediate;
		node.limit_drop_if_in_queue = n.limit_drop_if_in_queue;
	
		if (node.postgresConfig) {
	
			var connectionConfig = {
				user: node.postgresConfig.user,
				password: node.postgresConfig.password,
				host: node.postgresConfig.hostname,
				port: node.postgresConfig.port,
				database: node.postgresConfig.db,
				ssl: node.postgresConfig.ssl
			};
			node.pgpool=new pg.Pool(connectionConfig);
	
			var handleError = function(err, msg) {
				msg.error=err;
				node.error(err,msg);
				if (!!node.return_on_error)
					node.send(msg);
				console.log(err);
				console.log(msg.payload);
				console.log(msg.queryParameters);
			};

			node.msgsRunning=0;
			node.sqlsRunning=0;
			node.activeQueries=[];
			node.queryQueue=[];

			var queueCheck=()=>{
				let qq=node.queryQueue;
				node.queryQueue=[];
				while (qq.length>0)
					parseMsg(qq.shift());
				
			}
			
			var renewStatus=()=>{
				node.status({text:"sqls:"+node.sqlsRunning
						+(node.limit_queries==1?"/"+node.msgsRunning+"/"+node.limit_value:"")
						+(node.limit_queries==2?"/"+node.activeQueries.length:"")
						+(node.queryQueue.length>0?" queue:"+node.queryQueue.length:"")
				});
			}

			var setSqlCounter=(msg_inc,sql_inc)=>{
				node.msgsRunning+=msg_inc;
				node.sqlsRunning+=sql_inc;
				renewStatus();
			}
			var addActiveQuery=q=>{
				let a=(typeof q == "string")?q:JSON.stringify(q);
				if (!node.activeQueries.includes(a)) node.activeQueries.push(a);
			}
			var hasActiveQuery=q=>{
				let a=(typeof q == "string")?q:JSON.stringify(q);
				return node.activeQueries.includes(a);
			}
			var delActiveQuery=q=>{
				let a=(typeof q == "string")?q:JSON.stringify(q);
				node.activeQueries=node.activeQueries.filter(v=>v!=a);
			}
			var hasEnqueuedQuery=q=>{
				let a=(typeof q == "string")?q:JSON.stringify(q);
				return node.queryQueue.map(a=>(typeof a.payload=="string")?a.payload:JSON.stringify(a.payload)).includes(a);
			}
				
			var do_msg=(msg)=>{
				if (node.limit_queries==2)
					addActiveQuery(msg[node.limit_by]||msg.payload);
				setSqlCounter(1,0);

				node.pgpool.connect((err, client, done)=>{
					if (err) {
						handleError(err, msg);
						setTimeout(queueCheck,0);
					} else {
						named.patch(client);						

						var endConn=()=>{
							if (node.limit_queries==2)
								delActiveQuery(msg[node.limit_by]||msg.payload)
							setSqlCounter(-1,0);
							done();
							setTimeout(queueCheck,0);
						}

						if (msg.payload instanceof Array){
							if (!!node.perrow)
								node.warning("Splitting resultset is not allowed for multiple query processing.");
							Promise.all(msg.payload
								.filter(a=>!!a.query)
								.map(a=>{
									let qParams=[];
									if (!!a.queryParameters)
										qParams = a.queryParameters;
									if (!!a.params)
										qParams = a.params;
									setSqlCounter(0,1);
									return client.query(a.query,qParams)
										.then(data=>{
											setSqlCounter(0,-1);
											return data.rows;
										},err=>{
											setSqlCounter(0,-1);
											return {error:err};
										})
								})
							).then(data=>{
								endConn();
								msg.payload=data;
								node.send(msg);
								setTimeout(queueCheck,0);
							})
						}
						else {

							setSqlCounter(0,1);
						        
							let qParams=[];
							if (!!msg.queryParameters)
								qParams = msg.queryParameters;
							
							if (!node.perrow){
								var q=client.query(
									msg.payload,
									qParams,
									function(err, results) {
										setSqlCounter(0,-1);
										endConn();
										if (err) {
											handleError(err, msg);
										} else {
											if (node.output && !node.perrow) {
												msg.payload = results.rows;
												node.send(msg);
											}
										}
									}
								);
							}
							else {
								var cur=client.query(new Cursor(msg.payload,msg.queryParameters));
								var sndrow=(err,rows)=>{
									if (!!err) {
										handleError(err,msg);
										setSqlCounter(0,-1);
										endConn();
									}
									else {
										if (rows.length>0){
											node.send(Object.assign(Object.assign({},msg),{payload:((node.rowspermsg||1)>1)?rows:rows[0]}));
											cur.read(node.rowspermsg||1,sndrow);
										}
										else {
											setSqlCounter(0,-1);
											endConn();									
										}
									}
								}
								cur.read(node.rowspermsg||1,sndrow);
							}
						}
					}
				});
			};
			var parseMsg=msg=>{
				if (node.limit_queries==0)
					do_msg(msg);
				else if (node.limit_queries==1) {
					if (node.msgsRunning<(node.limit_value||1))
						do_msg(msg);
					else if (!node.limit_drop_intermediate){
						if (!!node.limit_drop_if_in_queue){
							if (!hasEnqueuedQuery(msg.payload))
								node.queryQueue.push(msg);
						}
						else node.queryQueue.push(msg);
					}
				}
				else if (node.limit_queries==2) {
					if (!hasActiveQuery(msg[node.limit_by]||msg.payload))
						do_msg(msg);
					else if (!node.limit_drop_intermediate){
						if (!!node.limit_drop_if_in_queue){
							if (!hasEnqueuedQuery(msg.payload))
								node.queryQueue.push(msg);
						}
						else node.queryQueue.push(msg);
					}
				}
				renewStatus();
			}
			node.on('input', parseMsg);
		} else {
			this.error("missing postgres configuration");
		}

		this.on("close", function() {
			if (node.clientdb) node.clientdb.end();
		});
	}

	RED.nodes.registerType("postgres", PostgresNode);
}