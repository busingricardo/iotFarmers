// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var machina = require("machina");
var dbg = require("debug");
var debug = dbg('azure-iot-mqtt-base:MqttBase');
var azure_iot_common_1 = require("azure-iot-common");
var OnTheWireMessage = /** @class */ (function () {
    function OnTheWireMessage(callback) {
        this.enqueuedTimeSecondsSinceEpoch = Math.floor(Date.now() / 1000);
        this.callback = callback;
    }
    return OnTheWireMessage;
}());
var OnTheWireMessageContainer = /** @class */ (function () {
    function OnTheWireMessageContainer() {
        this.timerCheckInMilliseconds = 10000;
        this.defaultTimeoutInSeconds = 30;
        this._timeoutInSeconds = this.defaultTimeoutInSeconds;
        //
        // Initializing the Map in the constructor.
        //
        this._onTheWire = new Map();
        this._identifier = 0;
    }
    OnTheWireMessageContainer.prototype.add = function (key, message) {
        this._onTheWire.set(key, message);
        if (this._onTheWire.size === 1) {
            //
            // This is the first entry into the container.  Start the
            // timer to check for timeouts
            //
            this._timeoutTimer = setTimeout(this._timeout.bind(this), this.timerCheckInMilliseconds);
        }
    };
    OnTheWireMessageContainer.prototype.complete = function (key, err, result) {
        var current = this._onTheWire.get(key);
        //
        // The message may have timed out or had an error, we would have already invoked the callback and
        // removed it from the dictionary.
        //
        // No need to try to do that again.
        //
        if (!!current) {
            this._onTheWire.delete(key);
            if (this._onTheWire.size === 0) {
                //
                // There are no more entries in the container.  No need to run the timer anymore.
                //
                clearTimeout(this._timeoutTimer);
            }
            current.callback(err, result);
        }
    };
    OnTheWireMessageContainer.prototype.purge = function (err) {
        var e_1, _a;
        var errorForPurgedMessage = err || new azure_iot_common_1.errors.NotConnectedError('Connect was lost');
        var existing = this._onTheWire;
        this._onTheWire = new Map();
        //
        // We stop the timer because there is nothing left in the onTheWire map anymore.
        //
        clearTimeout(this._timeoutTimer);
        try {
            for (var existing_1 = __values(existing), existing_1_1 = existing_1.next(); !existing_1_1.done; existing_1_1 = existing_1.next()) {
                var _b = __read(existing_1_1.value, 2), onTheWire = _b[1];
                onTheWire.callback(errorForPurgedMessage);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (existing_1_1 && !existing_1_1.done && (_a = existing_1.return)) _a.call(existing_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        existing.clear();
    };
    OnTheWireMessageContainer.prototype.setTimeoutInSeconds = function (timeout) {
        this._timeoutInSeconds = timeout;
    };
    OnTheWireMessageContainer.prototype.provideIdentifier = function () {
        this._identifier++;
        if (this._identifier === Number.MAX_VALUE) {
            this._identifier = 0;
        }
        return this._identifier;
    };
    OnTheWireMessageContainer.prototype._timeout = function () {
        var e_2, _a;
        var secondsSinceTheEpoch = Math.round(Date.now() / 1000);
        try {
            for (var _b = __values(this._onTheWire), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], onTheWireMessage = _d[1];
                if ((secondsSinceTheEpoch - onTheWireMessage.enqueuedTimeSecondsSinceEpoch) >= this._timeoutInSeconds) {
                    this._onTheWire.delete(key);
                    onTheWireMessage.callback(new azure_iot_common_1.errors.TimeoutError('Message not acknowledged'));
                }
                else {
                    //
                    // The Map object retains the order that items were inserted into it.
                    // The OnTheWireEntries must therefore have enqueue times that are monotonically
                    // increasing.  The first entry that does NOT timeout must be followed
                    // only by entries that also do NOT timeout.
                    //
                    break;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (this._onTheWire.size > 0) {
            //
            // Still some entries in the map. Re-schedule ourself.
            //
            this._timeoutTimer = setTimeout(this._timeout.bind(this), this.timerCheckInMilliseconds);
        }
    };
    return OnTheWireMessageContainer;
}());
/*Codes_SRS_NODE_COMMON_MQTT_BASE_16_004: [The `MqttBase` constructor shall instantiate the default MQTT.JS library if no argument is passed to it.]*/
/*Codes_SRS_NODE_COMMON_MQTT_BASE_16_005: [The `MqttBase` constructor shall use the object passed as argument instead of the default MQTT.JS library if it's not falsy.]*/
/**
 * @private
 */
var MqttBase = /** @class */ (function (_super) {
    __extends(MqttBase, _super);
    function MqttBase(mqttProvider) {
        var _this = _super.call(this) || this;
        _this.mqttProvider = mqttProvider ? mqttProvider : require('mqtt');
        _this._onTheWirePublishes = new OnTheWireMessageContainer();
        _this._fsm = new machina.Fsm({
            namespace: 'mqtt-base',
            initialState: 'disconnected',
            states: {
                disconnected: {
                    _onEnter: function (callback, err) {
                        debug('In MQTT base FSM - entered onEnter for disconnect');
                        //
                        // The semantics of this _onEnter for the disconnected state (which is the initial state)
                        // is that we got here from another one of the states of this FSM.
                        //
                        // So there was a disconnection.
                        //
                        // If there are any outstanding publishes, fail them.  We will never see
                        // their acknowledgements (PUBACK).  It is important to acknowledge that
                        // the publishes that were "on the wire", might indeed make it to the peer.  We'll
                        // never know.  If the code further up the stack retries, we could indeed get
                        // duplication of published data.  Nothing we can really do about it.
                        //
                        _this._onTheWirePublishes.purge(err);
                        //
                        // One of the other states was able to pass along a callback.  Use it to finish up whatever
                        // operation the state machine was working on.
                        //
                        // If there is no callback present, the clear implication is that something pretty major occurred,
                        // NOT in the context of any particular operation.  There is NO operation that this error can be reported
                        // as a result for.  Hence we emit the 'error' event.
                        //
                        if (callback) {
                            callback(err);
                        }
                        else {
                            if (err) {
                                debug('In mqtt base - no callback for error - emitting \'error\': ' + _this._errorDescription(err));
                                _this.emit('error', err);
                            }
                        }
                    },
                    connect: function (callback) { return _this._fsm.transition('connecting', callback); },
                    disconnect: function (callback) { return callback(); },
                    /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_020: [The `publish` method shall call the callback with a `NotConnectedError` if the connection hasn't been established prior to calling `publish`.]*/
                    publish: function (_topic, _payload, _options, callback) { return callback(new azure_iot_common_1.errors.NotConnectedError()); },
                    /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_026: [The `subscribe` method shall call the callback with a `NotConnectedError` if the connection hasn't been established prior to calling `publish`.]*/
                    subscribe: function (_topic, _options, callback) { return callback(new azure_iot_common_1.errors.NotConnectedError()); },
                    /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_027: [The `unsubscribe` method shall call the callback with a `NotConnectedError` if the connection hasn't been established prior to calling `publish`.]*/
                    unsubscribe: function (_topic, callback) { return callback(new azure_iot_common_1.errors.NotConnectedError()); },
                    updateSharedAccessSignature: function (callback) {
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_034: [The `updateSharedAccessSignature` method shall not trigger any network activity if the mqtt client is not connected.]*/
                        debug('updating shared access signature while disconnected');
                        callback();
                    }
                },
                connecting: {
                    _onEnter: function (connectCallback) {
                        _this._connectClient(function (err, connack) {
                            if (err) {
                                _this._fsm.transition('disconnecting', connectCallback, err);
                            }
                            else {
                                _this._mqttClient.on('error', _this._errorCallback.bind(_this));
                                _this._fsm.transition('connected', connectCallback, connack);
                            }
                        });
                    },
                    disconnect: function (callback) {
                        _this._fsm.transition('disconnecting', callback);
                    },
                    '*': function () { return _this._fsm.deferUntilTransition(); }
                },
                connected: {
                    _onEnter: function (connectCallback, connack) {
                        _this._mqttClient.on('close', _this._closeCallback.bind(_this));
                        connectCallback(null, new azure_iot_common_1.results.Connected(connack));
                    },
                    connect: function (callback) { return callback(null, new azure_iot_common_1.results.Connected()); },
                    disconnect: function (callback) { return _this._fsm.transition('disconnecting', callback); },
                    publish: function (topic, payload, options, callback) {
                        var thisPublishIdentifier = _this._onTheWirePublishes.provideIdentifier();
                        _this._onTheWirePublishes.add(thisPublishIdentifier, new OnTheWireMessage(callback));
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_017: [The `publish` method publishes a `payload` on a `topic` using `options`.]*/
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_021: [The  `publish` method shall call `publish` on the mqtt client object and call the `callback` argument with `null` and the `puback` object if it succeeds.]*/
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_022: [The `publish` method shall call the `callback` argument with an Error if the operation fails.]*/
                        _this._mqttClient.publish(topic, payload, options, function (err, result) {
                            _this._onTheWirePublishes.complete(thisPublishIdentifier, err, result);
                        });
                    },
                    subscribe: function (topic, options, callback) {
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_12_008: [The `subscribe` method shall call `subscribe`  on MQTT.JS  library and pass it the `topic` and `options` arguments.]*/
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_024: [The `subscribe` method shall call the callback with `null` and the `suback` object if the mqtt library successfully subscribes to the `topic`.]*/
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_025: [The `subscribe` method shall call the callback with an `Error` if the mqtt library fails to subscribe to the `topic`.]*/
                        _this._mqttClient.subscribe(topic, options, callback);
                    },
                    unsubscribe: function (topic, callback) {
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_028: [The `unsubscribe` method shall call `unsubscribe` on the mqtt library and pass it the `topic`.]*/
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_029: [The `unsubscribe` method shall call the `callback` argument with no arguments if the operation succeeds.]*/
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_030: [The `unsubscribe` method shall call the `callback` argument with an `Error` if the operation fails.]*/
                        _this._mqttClient.unsubscribe(topic, callback);
                    },
                    updateSharedAccessSignature: function (callback) {
                        _this._fsm.transition('reconnecting', callback);
                    },
                    closeEvent: function () {
                        _this._fsm.transition('disconnected', undefined, new azure_iot_common_1.errors.NotConnectedError('Connection to the server has been closed.'));
                    }
                },
                disconnecting: {
                    _onEnter: function (disconnectCallback, err) {
                        _this._disconnectClient(!!err, function () {
                            _this._fsm.transition('disconnected', disconnectCallback, err);
                        });
                    },
                    '*': function () { return _this._fsm.deferUntilTransition(); }
                },
                reconnecting: {
                    _onEnter: function (callback) {
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_033: [The `updateSharedAccessSignature` method shall disconnect and reconnect the mqtt client with the new `sharedAccessSignature`.]*/
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_035: [The `updateSharedAccessSignature` method shall call the `callback` argument with no parameters if the operation succeeds.]*/
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_036: [The `updateSharedAccessSignature` method shall call the `callback` argument with an `Error` if the operation fails.]*/
                        var switched = false;
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_41_002: [The `updateSharedAccessSignature` method shall trigger a forced disconnect if after 30 seconds the mqtt client has failed to complete a non-forced disconnect.]*/
                        /*Codes_SRS_NODE_COMMON_MQTT_BASE_41_003: [The `updateSharedAccessSignature` method shall call the `callback` argument with an `Error` if the operation fails after timing out.]*/
                        var disconnectTimeout = setTimeout(function () {
                            debug('disconnecting mqtt client timed out. Force disconnecting.');
                            switched = true;
                            _this._fsm.handle('forceDisconnect', callback);
                        }, 30000);
                        debug('disconnecting mqtt client');
                        _this._disconnectClient(false, function () {
                            clearTimeout(disconnectTimeout);
                            if (!switched) {
                                debug('mqtt client disconnected - reconnecting');
                                _this._connectClient(function (err, connack) {
                                    if (err) {
                                        debug('failed to reconnect the client: ' + err.toString());
                                        _this._fsm.transition('disconnected', callback, err);
                                    }
                                    else {
                                        debug('mqtt client reconnected successfully');
                                        _this._mqttClient.on('error', _this._errorCallback.bind(_this));
                                        _this._fsm.transition('connected', callback, connack);
                                    }
                                });
                            }
                        });
                    },
                    forceDisconnect: function (callback) {
                        debug('force disconnecting mqtt client');
                        _this._disconnectClient(true, function () {
                            debug('mqtt client disconnected - reconnecting');
                            _this._connectClient(function (err, connack) {
                                if (err) {
                                    debug('failed to reconnect the client: ' + err.toString());
                                    _this._fsm.transition('disconnected', callback, err);
                                }
                                else {
                                    debug('mqtt client reconnected successfully');
                                    _this._fsm.transition('connected', callback, connack);
                                }
                            });
                        });
                    },
                    '*': function () { return _this._fsm.deferUntilTransition(); }
                }
            }
        });
        _this._fsm.on('transition', function (data) {
            debug(data.fromState + ' -> ' + data.toState + ' (' + data.action + ')');
        });
        return _this;
    }
    MqttBase.prototype.connect = function (config, done) {
        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_006: [The `connect` method shall throw a ReferenceError if the config argument is falsy, or if one of the following properties of the config argument is falsy: uri, clientId, username, and one of sharedAccessSignature or x509.cert and x509.key.]*/
        if ((!config) ||
            (!config.uri) ||
            (!config.clientId) ||
            (!config.username) ||
            (!config.sharedAccessSignature && (!config.x509 || !config.x509.cert || !config.x509.key))) {
            throw new ReferenceError('Invalid transport configuration');
        }
        this._config = config;
        this._fsm.handle('connect', done);
    };
    MqttBase.prototype.disconnect = function (done) {
        this._fsm.handle('disconnect', done);
    };
    MqttBase.prototype.publish = function (topic, payload, options, done) {
        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_018: [The `publish` method shall throw a `ReferenceError` if the topic is falsy.]*/
        if (!topic) {
            throw new ReferenceError('Invalid topic');
        }
        this._fsm.handle('publish', topic, payload, options, done);
    };
    MqttBase.prototype.subscribe = function (topic, options, callback) {
        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_023: [The `subscribe` method shall throw a `ReferenceError` if the topic is falsy.]*/
        if (!topic) {
            throw new ReferenceError('Topic cannot be \'' + topic + '\'');
        }
        this._fsm.handle('subscribe', topic, options, callback);
    };
    MqttBase.prototype.unsubscribe = function (topic, callback) {
        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_031: [The `unsubscribe` method shall throw a `ReferenceError` if the `topic` argument is falsy.]*/
        if (!topic) {
            throw new ReferenceError('Topic cannot be \'' + topic + '\'');
        }
        this._fsm.handle('unsubscribe', topic, callback);
    };
    MqttBase.prototype.updateSharedAccessSignature = function (sharedAccessSignature, callback) {
        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_032: [The `updateSharedAccessSignature` method shall throw a `ReferenceError` if the `sharedAccessSignature` argument is falsy.]*/
        if (!sharedAccessSignature) {
            throw new ReferenceError('sharedAccessSignature cannot be \'' + sharedAccessSignature + '\'');
        }
        this._config.sharedAccessSignature = sharedAccessSignature;
        this._fsm.handle('updateSharedAccessSignature', callback);
    };
    /**
     * @private
     */
    MqttBase.prototype.setOptions = function (options) {
        this._options = options;
    };
    MqttBase.prototype.setTimeout = function (timeoutInSeconds) {
        this._onTheWirePublishes.setTimeoutInSeconds(timeoutInSeconds);
    };
    MqttBase.prototype._connectClient = function (callback) {
        var _this = this;
        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_002: [The `connect` method shall use the authentication parameters contained in the `config` argument to connect to the server.]*/
        var options = {
            protocolId: 'MQTT',
            protocolVersion: 4,
            clean: this._config.clean || false,
            clientId: this._config.clientId,
            rejectUnauthorized: true,
            username: this._config.username,
            reconnectPeriod: 0,
            /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_016: [The `connect` method shall configure the `keepalive` ping interval to 3 minutes by default since the Azure Load Balancer TCP Idle timeout default is 4 minutes.]*/
            keepalive: 180,
            reschedulePings: false
        };
        /*Codes_SRS_NODE_COMMON_MQTT_BASE_18_001: [The `connect` method shall set the `ca` option based on the `ca` string passed in the `options` structure via the `setOptions` function.]*/
        if (this._options) {
            if (this._options.ca) {
                options.ca = this._options.ca;
            }
            /*Codes_SRS_NODE_COMMON_MQTT_BASE_41_001: [The `connect` method shall set the `keepalive` option based on the `keepalive` numeric value passed in the `options` structure via the `setOptions` function.]*/
            if (this._options.keepalive) {
                options.keepalive = this._options.keepalive;
            }
            /*Codes_SRS_NODE_COMMON_MQTT_BASE_18_002: [The `connect` method shall set the `wsOptions.agent` option based on the `mqtt.webSocketAgent` object passed in the `options` structure via the `setOptions` function.]*/
            if (this._options.mqtt && this._options.mqtt.webSocketAgent) {
                options.wsOptions = {
                    agent: this._options.mqtt.webSocketAgent
                };
            }
        }
        if (this._config.sharedAccessSignature) {
            options.password = this._config.sharedAccessSignature.toString();
            debug('username: ' + options.username);
            debug('uri:      ' + this._config.uri);
        }
        else {
            options.cert = this._config.x509.cert;
            options.key = this._config.x509.key;
            options.passphrase = this._config.x509.passphrase; // forced to cast to any because passphrase is used by tls options but not surfaced by the types definition.
        }
        var createErrorCallback = function (eventName) {
            return function (error) {
                debug('received \'' + eventName + '\' from mqtt client');
                debug(' error supplied is: ' + _this._errorDescription(error));
                var err = error || new azure_iot_common_1.errors.NotConnectedError('Unable to establish a connection');
                callback(err);
            };
        };
        /*Codes_SRS_NODE_COMMON_MQTT_BASE_16_003: [The `connect` method shall call the `done` callback with a standard javascript `Error` object if the connection failed.]*/
        var errorCallback = createErrorCallback('error');
        var closeCallback = createErrorCallback('close');
        var offlineCallback = createErrorCallback('offline');
        var disconnectCallback = createErrorCallback('disconnect');
        this._mqttClient = this.mqttProvider.connect(this._config.uri, options);
        this._mqttClient.on('message', this._messageCallback.bind(this));
        this._mqttClient.on('error', errorCallback);
        this._mqttClient.on('close', closeCallback);
        this._mqttClient.on('offline', offlineCallback);
        this._mqttClient.on('disconnect', disconnectCallback);
        this._mqttClient.on('connect', function (connack) {
            debug('Device is connected');
            debug('CONNACK: ' + JSON.stringify(connack));
            _this._mqttClient.removeListener('error', errorCallback);
            _this._mqttClient.removeListener('close', closeCallback);
            _this._mqttClient.removeListener('offline', offlineCallback);
            _this._mqttClient.removeListener('disconnect', disconnectCallback);
            callback(null, connack);
        });
    };
    MqttBase.prototype._disconnectClient = function (forceDisconnect, callback) {
        if (this._mqttClient) {
            debug('removing all listeners');
            this._mqttClient.removeAllListeners();
            debug('adding null error listener');
            this._mqttClient.on('error', this._nullErrorCallback);
            /* Codes_SRS_NODE_COMMON_MQTT_BASE_16_001: [The disconnect method shall call the done callback when the connection to the server has been closed.] */
            this._mqttClient.end(forceDisconnect, callback);
        }
        else {
            debug('mqttClient is undefined');
            process.nextTick(callback);
        }
    };
    MqttBase.prototype._errorCallback = function (err) {
        debug('In base mqtt - error event received from mqtt.js client - error is: ' + this._errorDescription(err));
        this._fsm.transition('disconnecting', null, err);
    };
    MqttBase.prototype._closeCallback = function () {
        debug('In base mqtt - close event received from mqtt.js client - no error');
        this._fsm.handle('closeEvent');
    };
    MqttBase.prototype._nullErrorCallback = function () {
        return;
    };
    MqttBase.prototype._errorDescription = function (err) {
        return ((err) ?
            ((err.code) ||
                (err.name) ||
                (err.message) ||
                ('An error with no description')) :
            ('no error supplied'));
    };
    MqttBase.prototype._messageCallback = function (topic, payload) {
        var _this = this;
        process.nextTick(function () {
            _this.emit('message', topic, payload);
        });
    };
    return MqttBase;
}(events_1.EventEmitter));
exports.MqttBase = MqttBase;
//# sourceMappingURL=mqtt_base.js.map